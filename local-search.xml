<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>demo2</title>
    <link href="/2022/07/04/demo/"/>
    <url>/2022/07/04/demo/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/07/04/demo/1.jpg" alt="1"></p>]]></content>
    
    
    
    <tags>
      
      <tag>images</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MVC框架</title>
    <link href="/2022/07/03/MVC%E6%A1%86%E6%9E%B6/"/>
    <url>/2022/07/03/MVC%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="MVC框架模式与SpringMVC框架"><a href="#MVC框架模式与SpringMVC框架" class="headerlink" title="MVC框架模式与SpringMVC框架"></a>MVC框架模式与SpringMVC框架</h1><p><strong>框架通常是代码重用，而设计模式是设计重用。</strong></p><p><strong>框架的介绍：</strong><a href="https://blog.csdn.net/qq_36827957/article/details/78515403">https://blog.csdn.net/qq_36827957/article/details/78515403</a></p><p>MVC: Model View Controller 模型-视图-控制器</p><p>视图：用户看到并与之交互的界面。</p><p>模型：表示<strong>企业数据和业务规则</strong>。在MVC的3个部件中，模型拥有最多的处理任务。被模型返回的数据是独立的，与数据格式无关。这样的一个模式能够为多个视图提供数据，这样一来模型的代码只需要写一次便能够被多个视图重用，减少了代码的重复性。</p><p>控制器：接受用户的输入并调用相应的模型和视图来完成用户的需求，所以当用户点击web页面中的超链接和发送表单时，控制器本身不输出任何东西和做任何处理。它只是接收请求并根据请求来调用哪个模型去处理请求，然后在决定用哪个视图来显示返回的数据</p><h3 id="SpringMVC框架"><a href="#SpringMVC框架" class="headerlink" title="SpringMVC框架"></a><a href="https://so.csdn.net/so/search?q=SpringMVC&spm=1001.2101.3001.7020">SpringMVC</a>框架</h3><h4 id="1-1-SpringMVC简介"><a href="#1-1-SpringMVC简介" class="headerlink" title="1.1 SpringMVC简介"></a>1.1 SpringMVC简介</h4><p><strong>springMVC框架是基于Java的实现了MVC框架模式的请求驱动类型的轻量级框架</strong>。前端控制器是DispatcherServlet接口实现类，映射处理器是HandlerMapping接口实现类，视图解析器是ViewResolver接口实现类，页面控制器是Controller接口实现类。SpringMVC的工作流程图如下：<img src="/2022/07/03/MVC%E6%A1%86%E6%9E%B6/1.png" alt="img"></p><p>（1）客户端请求提交到前端控制器DispatcherServlet；<br>（2）前端控制器DispatcherServlet查找一个或者多个映射处理器HandlerMapping，从而确定调用哪个页面控制器Controller对请求进行处理；<br>（3）DispatcherServlet将请求提交给Controller；<br>（4）Controller根据业务逻辑对请求进行处理，并返回ModelAndView；<br>（5）DispatcherServlet查找一个或者多个ViewResolver，得到ModelAndView指定的视图view，并将model中的数据传入视图view中进行渲染；<br>（6）DispatcherServlet将渲染后的视图返回响应；</p><p>由上述过程可见，DispatcherServlet是Spring MVC的核心，它负责协调SpringMVC的各个组成部分对所有的Http请求进行处理，其主要工作如下：<br>（1）截获符合特定格式的Http请求；<br>（2）初始化DispatcherServlet上下文对应的WebApplicationContext，并将其与业务层、持久层的WebApplicationContext关联起来；<br>（3）初始化Spring MVC的各个组件，并装配到DispatcherServlet中；</p><h4 id="1-2-SpringMVC框架中的接口"><a href="#1-2-SpringMVC框架中的接口" class="headerlink" title="1.2 SpringMVC框架中的接口"></a>1.2 SpringMVC框架中的接口</h4><p>DispatcherServlet接口：Spring提供的前端控制器，所有的请求都是由它来进行分发。在DispatcherServlet将请求分发到对应的Controller之前，需要借助Spring提供的HandlerMapping才能定位到相应的Controller.</p><p>HandlerMapping接口：完成客户请求到Controller的映射。</p><p>Controller接口：需要为并发用户处理请求，在实现Controller接口时，必须保证线程安全且可重用。<br>在Controller完成用户请求的处理，返回ModelAndView对象给DispatcherServlet，ModelAndView对象中包含了模型Model和视图View。<br>从宏观角度进行考虑，DispatcherServlet是整个Web应用的控制器；从微观角度进行考虑，Controller是单个Http请求处理过程的控制器。</p><p>ViewResolver接口：根据ModelAndView对象在web应用查找view视图，并将model中是数据传入到view视图中进行渲染。</p><h4 id="1-3-SpringMVC框架优势"><a href="#1-3-SpringMVC框架优势" class="headerlink" title="1.3 SpringMVC框架优势"></a>1.3 SpringMVC框架优势</h4><p>（1）角色清晰，分工明确，进行更简介的web开发；<br>（2）和其他Spring框架无缝集成；<br>（3）强大的JSP标签库；<br>（4）HandlerMapping, ViewResolver等能够简单地进行定制；</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Springboot基础篇</title>
    <link href="/2022/07/03/Springboot%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <url>/2022/07/03/Springboot%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-Boot基础篇"><a href="#Spring-Boot基础篇" class="headerlink" title="Spring Boot基础篇"></a>Spring Boot基础篇</h1><h2 id="Restful风格"><a href="#Restful风格" class="headerlink" title="Restful风格"></a>Restful风格</h2><h3 id="REST开发"><a href="#REST开发" class="headerlink" title="REST开发"></a>REST开发</h3><p>REST，表现形式状态切换    </p><ul><li><p>传统风格资源描述形式</p><p><a href="http://localhost/user/getById?id=1">http://localhost/user/getById?id=1</a></p><p><a href="http://localhost/user/saveUser">http://localhost/user/saveUser</a></p></li><li><p>REST风格描述形式</p><p><a href="http://localhost/user/1">http://localhost/user/1</a></p><p><a href="http://localhost/user">http://localhost/user</a></p></li></ul><p>优点：</p><ul><li>隐藏资源的访问行为，无法通过地址得知对资源是何种操作</li><li>书写简化</li></ul><p><strong>@RestController</strong>:将当前控制器类设置为RESTful风格，等同于@Controller与@ResponseBody两个注解组合功能</p><p><a href="https://cloud.tencent.com/developer/article/1046622">SpringMVC 常用注解 - 云+社区 - 腾讯云 (tencent.com)</a></p><p>将请求参数放入请求路径中，再由注解**@PathVariable**(“对应请求参数的名称”) 从而获得相对应的值，有多个参数就多个使用</p><p><a href="https://restfulapi.cn/">RESTful API 一种流行的 API 设计风格</a></p><p>Restful原则：行为操作(资源的访问形式)</p><ul><li>增：post请求    <strong>@PostMapping</strong></li><li>删：delete请求 <strong>@DeleteMapping</strong></li><li>改：put请求      <strong>@PutMapping</strong></li><li>查：get请求       <strong>@GetMapping</strong></li></ul><p>一般来说请求路径不要出现动词</p><p>分页，排序等操作，不需要使用斜杠传参，一般传的参数不是数据库表的字段，可以不采用斜杠</p><h3 id="RequestBody-RequestParam-PathVariable"><a href="#RequestBody-RequestParam-PathVariable" class="headerlink" title="@RequestBody  @RequestParam  @PathVariable"></a>@RequestBody  @RequestParam  @PathVariable</h3><ul><li>区别<ul><li>@RequestParam 用于接收url地址传参或者表单传参</li><li>@RequestBody用于接收json数据</li><li>@PathVariable用于接收路径参数，使用{参数名称}描述路径参数</li></ul></li><li>应用<ul><li>后期开发中，发送请求参数超过1个时，以json格式为主，@RequestBody 应用较广</li><li>如果发送非json格式数据，选用@RequestParam接收请求参数</li><li>采用RESTful进行开发，当参数较少时，例如1个，可以采用@PathVariable接收请求路径变量，通常用于传递id值</li></ul></li></ul><h2 id="springboot应用"><a href="#springboot应用" class="headerlink" title="springboot应用"></a>springboot应用</h2><p>springboot是简化Spring应用的初始搭建和开发过程  springboot简化了依赖的配置</p><p><a href="https://www.cnblogs.com/fishpro/p/spring-boot-study-restcontroller.html">Spring Boot Web 开发@Controller @RestController 使用教程 - fishpro - 博客园 (cnblogs.com)</a></p><p>将spring的配置文件和spring-mvc配置简化了</p><p>springboot的配置文件中 pom文件的继承父类的文件，父类的文件里规定了dependency坐标依赖的最好版本 自动配置</p><h3 id="starter和parent"><a href="#starter和parent" class="headerlink" title="starter和parent"></a>starter和parent</h3><ul><li>starter<ul><li>springboot中常见的项目名称，定义了当前项目使用的所有依赖坐标，以达到减少依赖配置的目的</li></ul></li><li>parent<ul><li>所有SpringBoot项目要继承的项目，定义了若干个坐标版本号(依赖管理，而非依赖)，以达到减少依赖冲突的目的</li><li>spring-boot-starter-parent各版本间存在着诸多坐标版本不同</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>实际开发    GAV(G:groupId A:artifactId V:version)<ul><li>使用任意坐标时，仅写GAV中的G和A，V由SpringBoot提供，除非SpringBoot为提供对应版本V</li><li>如果发生坐标错误，则需要手动指定Version(但要小心版本冲突)</li></ul></li></ul><h3 id="引导类"><a href="#引导类" class="headerlink" title="引导类"></a>引导类</h3><p>SpringBoot的引导类是Boot工厂的执行入口，通过mian方法就可以启动项目</p><p>加载spring容器 默认扫描对应包及其子包的内容 实例bean 放入spring容器</p><p><img src="/2022/07/03/Springboot%E5%9F%BA%E7%A1%80%E7%AF%87/1.png" alt="层次"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringbootQuickApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(SpringbootQuickApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="内嵌tomcat-springboot支持切换web服务器"><a href="#内嵌tomcat-springboot支持切换web服务器" class="headerlink" title="内嵌tomcat(springboot支持切换web服务器)"></a>内嵌tomcat(springboot支持切换web服务器)</h3><p>在pom文件里引入的spring-boot-starter-web里自动加载tomcat服务器</p><p>tomcat的本质是用java语言编写的执行过程 现在SpringBoot将tomcat的执行过程<strong>封装成一个对象</strong>放入spring容器里，需要使用web程序直接引用tomcat对象，从而在tomcat上执行，所以SpringBoot不用配置tomcat服务器也可以使用tomcat</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>变更内嵌服务器：是将现有的服务器去除，添加全新的服务器</p><p>SpringBoot可以支持切换内置服务器有三个</p><ul><li>tomcat(默认)        apache出品，<strong>应用面广</strong>，负载若干较重的组件</li><li>jetty                       <strong>更轻量级</strong>，可扩展性更高，负载性能远不及tomcat</li><li>undertow             负载性能<strong>勉强</strong>跑赢tomcat</li></ul><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><h3 id="复制工程-快速新建模块"><a href="#复制工程-快速新建模块" class="headerlink" title="复制工程(快速新建模块)"></a>复制工程(快速新建模块)</h3><ul><li>原则<ul><li>保留工程基础结构</li><li>抹掉原始工程痕迹</li></ul></li></ul><p>在工作空间里复制对应工程，兵修改过程名称</p><p>删除与Idea相关的配置文件，仅保留src目录和pom文件</p><p>修改pom文件中的artifactId与新工程/模块名相同</p><p>保留备份后期使用</p><p>springboot配置文件(三种)：</p><ul><li><strong>application.properties</strong> （主导）使用key-value的格式</li></ul><p>server.port=80</p><ul><li><strong>application.yml(主流)</strong></li></ul><p>server:</p><p>​    port: 80</p><ul><li><strong>application.yaml</strong>(配置同上)</li></ul><p>不同配置文件中相同配置按照加载优先级相互覆盖，不同配置文件中不同配置全部保留</p><h3 id="yml配置文件里属性"><a href="#yml配置文件里属性" class="headerlink" title="yml配置文件里属性"></a>yml配置文件里属性</h3><h4 id="使用-Value注解读取单个属性"><a href="#使用-Value注解读取单个属性" class="headerlink" title="使用@Value注解读取单个属性"></a>使用@Value注解读取单个属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Value(&quot;$&#123;country&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String country1;<br></code></pre></td></tr></table></figure><h4 id="使用-Autowired获得全部属性"><a href="#使用-Autowired获得全部属性" class="headerlink" title="使用@Autowired获得全部属性"></a>使用@Autowired获得全部属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自动装配 yml配置文件里的全部属性</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> Environment env;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">env.getProperty(<span class="hljs-string">&quot;user.name&quot;</span>)<br></code></pre></td></tr></table></figure><p>加载实体的get set方法使用<strong>lombok</strong>里注解**@Data<strong>自动加载，需要在pom文件加入</strong>lombok**的坐标</p><p>将一个类转换为bean用spring注解：**@Component**将其转换为bean并放入spring容器里</p><p>获得yml指定区域数据：**@ConfigurationProperties(prefix=”字段名”)**</p><h2 id="springboot整合junit"><a href="#springboot整合junit" class="headerlink" title="springboot整合junit"></a>springboot整合junit</h2><p> 测试类需要在启动类的包或子包中，可以省略启动类的设置，也就是省略calsses的设定</p><p>否则需要使用**@SpringBootTest(calsses = 启动类名)**注解来查找</p><p>SpringBoot整合junit相当于spring整合junit</p><p><strong>spring整合junit是 使用@RunWith()+ContextConfiguration(calsses = 启动类名)</strong></p><p>**而springboot是使用@SpringBootTest(calsses = 启动类名)**注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest(classes = Springboot03JunitApplication.class)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Springboot03JunitApplicationTests</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> BookDao bookDao;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>        bookDao.save();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="springboot整合mybatis"><a href="#springboot整合mybatis" class="headerlink" title="springboot整合mybatis"></a>springboot整合mybatis</h2><p>在yml配置文件里添加配置数据库的相对应信息</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># 配置相关信息</span><br><span class="hljs-attr">spring:</span><br>   <span class="hljs-attr">datasource:</span><br>      <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>      <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/test</span><br>      <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>      <span class="hljs-attr">password:</span> <span class="hljs-string">nian0209</span><br></code></pre></td></tr></table></figure><p>创建实体类domain和dao实现操作数据库的方法    注意：<strong>实体类名应该和数据库的字段名一致</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Springboot04MybatisApplicationTests</span> &#123;<br><br>    <span class="hljs-comment">//这里虽是接口的注入但实际注入的对象是实现类的对象</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> BookDao bookDao;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(bookDao.getById(<span class="hljs-number">2</span>));<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="至于在controller层上使用的service的接口而不是实现类"><a href="#至于在controller层上使用的service的接口而不是实现类" class="headerlink" title="至于在controller层上使用的service的接口而不是实现类"></a>至于在controller层上使用的service的接口而不是实现类</h2><p>因为通过**@Autowired<strong>的对象是通过接口的方式会使用</strong>jdk的动态代理**，jdk的动态代理针对接口产生代理，动态的产生实现类的对象，在注入到spring容器里也是实现类的对象 这样使用jdk代理的方式动态的生成接口的实现类，还可以实现对实现类的增强从而做到增强类</p><h3 id="一个接口里有多个实现类"><a href="#一个接口里有多个实现类" class="headerlink" title="一个接口里有多个实现类"></a>一个接口里有多个实现类</h3><p><a href="https://dalin.blog.csdn.net/article/details/116573967?spm=1001.2101.3001.6650.13&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-13-116573967-blog-102260648.pc_relevant_antiscanv2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-13-116573967-blog-102260648.pc_relevant_antiscanv2&utm_relevant_index=15"> Spring中如Service有多个实现类，它怎么知道该注入哪个ServiceImpl类？_Java知音_的博客-CSDN博客</a></p><p>@Primary：自动装配时当出现多个Bean候选者时，被注解为@Primary的Bean将作为首选者，否则将抛出异常 </p><p>@Autowired 默认按类型装配，如果我们想使用按名称装配，可以结合@Qualifier注解一起使用</p><p> @Autowired</p><p>@Qualifier(“personDaoBean”) 存在多个实例配合使用</p><p>在service层使用@Service(名称)来将实现方法带名称的注入到spring容器里</p><p>使用@Autowired自动注入，</p><p>**@Qualifier(“beanId”)**：beanId是指对应实现类的类名称且字母开头小写</p><ul><li><strong>方法一：</strong> Controller中注入service的时候使用**@Autowired**自动注入，<code>@Qualifier(&quot;beanId&quot;)</code>来指定注入哪一个。</li><li><strong>方法二：</strong> Controller中注入service的时候使用<code>@Resource(type = 类名.class)</code>来指定注入哪一个。</li><li><strong>方法三：</strong><ul><li>每个service的impl都可以指定名称（使用<code>@Service（“名称”）</code>）</li><li>Controller中注入service的时候使用名称来指定注入哪一个（使用<code>@Resource(name=&quot;名称&quot;)</code>）</li></ul></li></ul><p><strong>@Autowired注解的意思就是:</strong></p><p>当Spring发现<code>@Autowired</code>注解时，将自动在代码上下文中找到和其匹配（默认是类型匹配）的Bean，并自动注入到相应的地方去。</p><p><code>@Resource</code>的作用相当于<code>@Autowired</code>。</p><p><strong>@Autowired和@Resource两个注解的区别：</strong></p><p>1.<code>@Autowired</code>是Spring的注解，<code>@Resource</code>是J2EE的注解，这个看一下导入注解的时候这两个注解的包名就一清二楚了。</p><p>2.<code>@Autowired</code>默认按照byType(方法类型)方式进行bean匹配，<code>@Resource</code>默认按照byName(方法名称)方式进行bean匹配。</p><p>3.@Autowired默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置它的required属性为false，如：<code>@Autowired(required=false)</code>。</p><h2 id="springboot整合MyBatis-Plus"><a href="#springboot整合MyBatis-Plus" class="headerlink" title="springboot整合MyBatis-Plus"></a>springboot整合MyBatis-Plus</h2><ul><li>MyBatis-plus与MyBatis区别<ul><li>导入坐标不同</li><li>数据层实现简化</li></ul></li></ul><p>手动导入MP坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="springboot整合Druid"><a href="#springboot整合Druid" class="headerlink" title="springboot整合Druid"></a>springboot整合Druid</h2><p>导入Druid对应的starter</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在yml配置文件中配置druid数据源</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># Druid整合</span><br><span class="hljs-attr">spring:</span><br>   <span class="hljs-attr">datasource:</span><br>      <span class="hljs-attr">druid:</span><br>         <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>         <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/test</span><br>         <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>         <span class="hljs-attr">password:</span> <span class="hljs-string">nian0209</span><br></code></pre></td></tr></table></figure><h1 id="SSMP整合案例"><a href="#SSMP整合案例" class="headerlink" title="SSMP整合案例"></a>SSMP整合案例</h1><p>基于springboot</p><ul><li>案列方案分析<ul><li>实体类开发—使用lombok快速制作实体类</li><li>Dao开发—整合MyBatisPlus，制作数据层测试类</li><li>Service开发—基于MyBatisPlus进行增量开发，制作业务层测试类</li><li>Controller开发—基于Restful开发，使用PostMan进行接口测试</li><li>Controller开发—前后端开发协议制作(前后端数据交换形式)</li><li>页面开发—基于VUE+ElementUI制作，前后端联调，页面数据处理，页面消息处理<ul><li>列表，新增，修改，删除，分页，查询</li></ul></li><li>项目异常处理</li><li>按条件查询—页面功能调整，Controller修正功能，Service修正功能</li></ul></li></ul><h2 id="准备步骤"><a href="#准备步骤" class="headerlink" title="准备步骤"></a>准备步骤</h2><p>勾选springweb 和 mysql对应坐标 </p><p>修改配置文件为yml格式并设置端口并设置自动增长的属性 开启日志</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">mybatis-plus:</span><br>  <span class="hljs-attr">global-config:</span><br>    <span class="hljs-attr">db-config:</span><br><span class="hljs-comment">#      设置id自增</span><br>      <span class="hljs-attr">id-type:</span> <span class="hljs-string">auto</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-attr">log-impl:</span> <span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span><br></code></pre></td></tr></table></figure><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>使用MP快速的查看分页的数据，但是需要指定spring拦截器 在使用语句前也需要传入分页对应的参数—-(第几页，几条数据)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">IPage</span> <span class="hljs-variable">page</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);<br>bookDao.selectPage(page,<span class="hljs-literal">null</span>);<br> <span class="hljs-comment">//打印当前页内数据</span><br>System.out.println(page.getRecords());<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MPConfig</span> &#123;<br><br>    <span class="hljs-comment">//使用拦截器创建分页</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MybatisPlusInterceptor <span class="hljs-title function_">mybatisPlusInterceptor</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//定义MP拦截器</span><br>        <span class="hljs-type">MybatisPlusInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MybatisPlusInterceptor</span>();<br>        <span class="hljs-comment">//添加具体的拦截器</span><br>        interceptor.addInnerInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PaginationInnerInterceptor</span>());<br>        <span class="hljs-keyword">return</span>  interceptor;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><p>使用QueryWrapper则需要自己去写对应匹配查询的字段，使用LambdaQueryWrapper则直接get就行了</p><p>like方法里可以添加判断条件：不为空的时候才执行条件查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//按条件查询</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testBy</span><span class="hljs-params">()</span> &#123;<br><br>    QueryWrapper&lt;Book&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>    queryWrapper.like(<span class="hljs-literal">true</span>,<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;学&quot;</span>);<br>    bookDao.selectList(queryWrapper);<br><br>&#125;<br><span class="hljs-comment">//按条件查询</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testBy2</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    LambdaQueryWrapper&lt;Book&gt; lambdaQueryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;&gt;();<br>    lambdaQueryWrapper.like(name!=<span class="hljs-literal">null</span>,Book::getName,name);<br>    bookDao.selectList(lambdaQueryWrapper);<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="业务层-快速开发"><a href="#业务层-快速开发" class="headerlink" title="业务层-快速开发"></a>业务层-快速开发</h2><p>实现Service接口和实现类</p><p>使用MyBatisPlus提供业务层通用接口(IService<T>)与业务层通用实现类(ServiceImpl&lt;M,T&gt;)</T></p><p>在通用类基础上做功能重载或追加</p><p>注意重载时不要覆盖原始操作，避免原始提供的功能丢失—–可以在方法名上添加@Override查看有无重名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IBookService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IService</span>&lt;Book&gt; &#123;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IBookServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceImpl</span>&lt;BookDao, Book&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IBookService</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="表现层展示"><a href="#表现层展示" class="headerlink" title="表现层展示"></a>表现层展示</h2><p>接收参数：</p><p>实体数据：@RequestBody</p><p>路径变量：@PathVariable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/books&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> IBookService bookService;<br><span class="hljs-comment">//查</span><br>    <span class="hljs-meta">@GetMapping</span><br>    <span class="hljs-keyword">public</span> List&lt;Book&gt; <span class="hljs-title function_">getAll</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> bookService.list();<br>    &#125;<br><span class="hljs-comment">//增</span><br>    <span class="hljs-meta">@PostMapping</span><br>    <span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">save</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Book book)</span>&#123;<br>        <span class="hljs-keyword">return</span> bookService.save(book);<br>    &#125;<br><span class="hljs-comment">//改</span><br>    <span class="hljs-meta">@PutMapping</span><br>    <span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Book book)</span>&#123;<br>        <span class="hljs-keyword">return</span> bookService.modify(book);<br>    &#125;<br><span class="hljs-comment">//删</span><br>    <span class="hljs-meta">@DeleteMapping(&quot;&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> <span class="hljs-type">int</span> id)</span>&#123;<br>        <span class="hljs-keyword">return</span> bookService.delete(id);<br>    &#125;<br><span class="hljs-comment">//查</span><br>    <span class="hljs-meta">@GetMapping(&quot;&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> Book <span class="hljs-title function_">getById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> <span class="hljs-type">int</span> id)</span>&#123;<br>        <span class="hljs-keyword">return</span> bookService.getById(id);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="表现层信息一致性处理"><a href="#表现层信息一致性处理" class="headerlink" title="表现层信息一致性处理"></a>表现层信息一致性处理</h3><p>设计表现层返回结果的模型类，用于后端和前端进行数据格式统一，也称为前后端数据协议</p><p>flag：代表查询是否成功</p><p>data：存放数据</p><p>同意表现层数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">R</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> flag;<br>    <span class="hljs-keyword">private</span> Object data;<br>    R()&#123;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">R</span><span class="hljs-params">(Boolean flag)</span>&#123;<br>        <span class="hljs-built_in">this</span>.flag =flag;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">R</span><span class="hljs-params">(Boolean flag,Object data)</span>&#123;<br>        <span class="hljs-built_in">this</span>.data = data;<br>        <span class="hljs-built_in">this</span>.flag = flag;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">R</span><span class="hljs-params">(Boolean flag,String msg)</span>&#123;<br>        <span class="hljs-built_in">this</span>.flag = flag;<br>        <span class="hljs-built_in">this</span>.msg = msg;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">R</span><span class="hljs-params">(String msg)</span>&#123;<br>        <span class="hljs-built_in">this</span>.flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">this</span>.msg = msg;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="前后端-页面"><a href="#前后端-页面" class="headerlink" title="前后端 页面"></a>前后端 页面</h2><p>前后端协议联调</p><ul><li>前后端分离结构设计在页面归属前端服务器</li><li>单体工程页面在resoures目录下的static目录中(建议执行clean)</li></ul><p>发送异步请求，调用后端接口</p><p>axios.get(“/books”).then((res)=&gt;{</p><p>​        数据连接</p><p>});</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>自定义springmvc的异常处理类来处理异常 在类上添加@RestControllerAdvice定义restful风格异常处理类且返回的数据给前端也需要和</p><p>前后端数据协议一致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//作为springmvc的异常处理器</span><br><span class="hljs-comment">//@ControllerAdvice</span><br><span class="hljs-meta">@RestControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProjectExceptionAdvice</span> &#123;<br>    <span class="hljs-comment">//拦截所有的异常信息</span><br>    <span class="hljs-meta">@ExceptionHandler(Exception.class)</span><br>    <span class="hljs-keyword">public</span> R <span class="hljs-title function_">doException</span><span class="hljs-params">(Exception ex)</span>&#123;<br>        <span class="hljs-comment">//记录日志</span><br>        <span class="hljs-comment">//通知运维</span><br>        <span class="hljs-comment">//通知开发</span><br>        ex.printStackTrace();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">R</span>(<span class="hljs-string">&quot;服务器故障，请稍后再试！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="条件查询-1"><a href="#条件查询-1" class="headerlink" title="条件查询"></a>条件查询</h2><p>分页部分的条件查询是根据v-model动态模型，在分页的基础上动态的添加查询数据，一起传到后端</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//分页查询</span><br><span class="hljs-title function_">getAll</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">//组织参数，拼接url请求地址</span><br>    <span class="hljs-comment">// console.log(this.pagination.type);</span><br>    param = <span class="hljs-string">&quot;?type=&quot;</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">pagination</span>.<span class="hljs-property">type</span>;<br>    param +=<span class="hljs-string">&quot;&amp;name=&quot;</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">pagination</span>.<span class="hljs-property">name</span>;<br>    param +=<span class="hljs-string">&quot;&amp;description=&quot;</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">pagination</span>.<span class="hljs-property">description</span>;<br>    <span class="hljs-comment">// console.log(param);</span><br><br>    <span class="hljs-comment">//发送异步请求</span><br>    axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/books/&quot;</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">pagination</span>.<span class="hljs-property">currentPage</span>+<span class="hljs-string">&quot;/&quot;</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">pagination</span>.<span class="hljs-property">pageSize</span>+param).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>)=&gt;</span>&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">pagination</span>.<span class="hljs-property">pageSize</span> = res.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>.<span class="hljs-property">size</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">pagination</span>.<span class="hljs-property">currentPage</span> = res.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>.<span class="hljs-property">current</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">pagination</span>.<span class="hljs-property">total</span> = res.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>.<span class="hljs-property">total</span>;<br><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">dataList</span> = res.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>.<span class="hljs-property">records</span>;<br>    &#125;);<br>&#125;,<br></code></pre></td></tr></table></figure><p>service层判断条件查询有无值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> IPage&lt;Book&gt; <span class="hljs-title function_">getPage</span><span class="hljs-params">(<span class="hljs-type">int</span> currentPage, <span class="hljs-type">int</span> pageSize, Book book)</span> &#123;<br>    LambdaQueryWrapper&lt;Book&gt; lqw = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;Book&gt;();<br>    lqw.like(Strings.isNotEmpty(book.getType()),Book::getType,book.getType());<br>    lqw.like(Strings.isNotEmpty(book.getName()),Book::getName,book.getName());<br>    lqw.like(Strings.isNotEmpty(book.getDescription()),Book::getDescription,book.getDescription());<br>    <span class="hljs-type">IPage</span> <span class="hljs-variable">page</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>(currentPage,pageSize);<br>    bookDao.selectPage(page,lqw);<br>    <span class="hljs-keyword">return</span> page;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="elementUI"><a href="#elementUI" class="headerlink" title="elementUI"></a>elementUI</h2><p>分页插件</p><p>分页bug：一页中只有一个数据的时候。删除这个数据后当前页不会有信息展示，例如：原来有三页，删除了一页中只有一个数据的时候，系统还是在查删除完了那页，所以不会显示数据</p><p>解决方法：一般是在后台判断当前页是不是比总页数大，为true则返回最大页数数据  ———–但这也还是有bug</p><p>较好的解决方法是直接返回第一页</p><p>根本：根据需求修改</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--分页组件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pagination-container&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">el-pagination</span></span><br><span class="hljs-tag">            <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pagiantion&quot;</span></span><br><span class="hljs-tag"></span><br><span class="hljs-tag">            @<span class="hljs-attr">current-change</span>=<span class="hljs-string">&quot;handleCurrentChange&quot;</span></span><br><span class="hljs-tag"></span><br><span class="hljs-tag">            <span class="hljs-attr">:current-page</span>=<span class="hljs-string">&quot;pagination.currentPage&quot;</span></span><br><span class="hljs-tag"></span><br><span class="hljs-tag">            <span class="hljs-attr">:page-size</span>=<span class="hljs-string">&quot;pagination.pageSize&quot;</span></span><br><span class="hljs-tag"></span><br><span class="hljs-tag">            <span class="hljs-attr">layout</span>=<span class="hljs-string">&quot;total, prev, pager, next, jumper&quot;</span></span><br><span class="hljs-tag"></span><br><span class="hljs-tag">            <span class="hljs-attr">:total</span>=<span class="hljs-string">&quot;pagination.total&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">el-pagination</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-meta">@GetMapping(&quot;&#123;currentPage&#125;/&#123;pageSize&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> R <span class="hljs-title function_">getPage</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> <span class="hljs-type">int</span> currentPage,<span class="hljs-meta">@PathVariable</span> <span class="hljs-type">int</span> pageSize,Book book)</span>&#123;<br><span class="hljs-comment">//        System.out.println(&quot;参数==&gt;&quot;+book);</span><br><br>        IPage&lt;Book&gt; page = bookService.getPage(currentPage, pageSize,book);<br>        <span class="hljs-comment">//如果当前页码值大于了总页码值，那么重新执行查询操作，使用最大页码值作为当前页码值</span><br>        <span class="hljs-keyword">if</span>( currentPage &gt; page.getPages())&#123;<br>            page = bookService.getPage((<span class="hljs-type">int</span>)page.getPages(), pageSize,book);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">R</span>(<span class="hljs-literal">true</span>, page);<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>在对应的实体类中，如果数据库和实体类的字段是驼峰命名MP会将其转化为下划线形式，如果需要对应有三种办法</p><ul><li><p>将数据库表字段改为下划线形式</p></li><li><p>在实体类字段上添加@tableFiled(“字段名”)</p></li><li><p>在yml配置文件中的mybatis-pus添加</p></li><li><pre><code class="yml">mybatis-plus:  configuration:    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl    map-underscore-to-camel-case: false #关闭驼峰映射</code></pre></li></ul><p>实体类有主键的需要在实体类主键字段头添加@TableId(type = IdType.AUTO（自增长类型）)</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis-Plus</title>
    <link href="/2022/07/02/MyBatis-Plus/"/>
    <url>/2022/07/02/MyBatis-Plus/</url>
    
    <content type="html"><![CDATA[<h1 id="MyBatis-Plus"><a href="#MyBatis-Plus" class="headerlink" title="MyBatis-Plus"></a>MyBatis-Plus</h1><p><a href="https://baomidou.com/pages/24112f/#%E7%89%B9%E6%80%A7">简介 | MyBatis-Plus (baomidou.com)</a></p><h2 id="MyBatis-plus-MyBatis"><a href="#MyBatis-plus-MyBatis" class="headerlink" title="MyBatis-plus +MyBatis"></a>MyBatis-plus +MyBatis</h2><p>简单的整合mybatis里操作数据库的方法</p><ul><li>将对应的Mapper对象继承BaseMapper<T>(使其能调用BaseMpper里的操作方法)</T></li><li>使用MyBatis-plus 的方式产生SqlSessionFactory</li><li>最后调用BaseMapper的方法操作数据库</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testUserList</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(resource);<br>    <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span><br>            <span class="hljs-comment">//这里使用的是MP中的MybatisSqlSessionFactoryBuilder</span><br>            MybatisSqlSessionFactoryBuilder().build(inputStream);<br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();<br>    <span class="hljs-type">UserMapper</span> <span class="hljs-variable">userMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class);<br>    <span class="hljs-comment">// 可以调用BaseMapper中定义的方法</span><br>    List&lt;User&gt; list = userMapper.selectList(<span class="hljs-literal">null</span>);<br>    <span class="hljs-keyword">for</span> (User user : list) &#123;<br>        System.out.println(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>子项目都继承了父项目来引用mybatis-plus</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="MyBatis-plus-Spring"><a href="#MyBatis-plus-Spring" class="headerlink" title="MyBatis-plus +Spring"></a>MyBatis-plus +Spring</h2><p>整合Spring+MyBatis-plus主要是解析数据源，将配置信息写在spring的配置文件中</p><p>pom文件中需要导入spring的mybatis-plus的配置</p><p><artifactId>itcast-mybatis-plus-spring</artifactId></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--扫描配置源    --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:*.properties&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!-- 定义数据源 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;close&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxActive&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;10&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;minIdle&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;5&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-comment">&lt;!--这里使用MP提供的sqlSessionFactory，完成了Spring与MP的整合--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.baomidou.mybatisplus.extension.spring.MybatisSqlSessionFactoryBean&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-comment">&lt;!--扫描mapper接口，使用的依然是Mybatis原生的扫描器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basePackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;cn.itcast.mp.simple.mapper&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>spring也是同样引用mybatis-plus</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="Springboot-Mybatis-plus"><a href="#Springboot-Mybatis-plus" class="headerlink" title="Springboot+Mybatis-plus"></a>Springboot+Mybatis-plus</h2><p>需要在application.yml的配置文件中配置数据源，而其他的映射或者扫描器springboot已经注解封装完成不需要自己重复写</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># 配置数据源</span><br><span class="hljs-attr">spring:</span><br>   <span class="hljs-attr">datasource:</span><br>      <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>      <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/test</span><br>      <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>      <span class="hljs-attr">password:</span> <span class="hljs-string">nian0209</span><br></code></pre></td></tr></table></figure><p>pom文件里springboot项目需要引用父类文件</p><p><strong><u>spring-boot-starter-parent</u></strong> 里面封装了springboot项目的启动对应的配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br></code></pre></td></tr></table></figure><p>引用mybatis-plus需要引用springboot对应的mybatis-plus配置信息</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="BaseMapper提供的CRUD"><a href="#BaseMapper提供的CRUD" class="headerlink" title="BaseMapper提供的CRUD"></a>BaseMapper提供的CRUD</h3><h4 id="TableField"><a href="#TableField" class="headerlink" title="@TableField"></a>@TableField</h4><p>在MP中通过@TableField注解可以指定字段的一些属性，常常解决的问题有2个：<br>1、对象中的属性名和字段名不一致的问题（非驼峰）<br>2、对象中的属性字段在表中不存在的问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@TableName(&quot;tb_user&quot;)</span> <span class="hljs-comment">//指定数据库表名</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-meta">@TableId(type = IdType.AUTO)</span> <span class="hljs-comment">//主键自增长</span><br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String userName;<br>    <span class="hljs-meta">@TableField(select = false)</span> <span class="hljs-comment">//查询不显示详细值</span><br>    <span class="hljs-keyword">private</span> String password;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-meta">@TableField(value = &quot;email&quot;)</span> <span class="hljs-comment">//字段名不一样</span><br>    <span class="hljs-keyword">private</span> String email;<br>    <span class="hljs-meta">@TableField(exist = false)</span><br>    <span class="hljs-keyword">private</span> String address; <span class="hljs-comment">//该字段在数据库中不存在</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="更新操作"><a href="#更新操作" class="headerlink" title="更新操作"></a>更新操作</h4><p>在MP中，更新操作有2种，一种是根据id更新，另一种是根据条件更新</p><h5 id="根据id更新"><a href="#根据id更新" class="headerlink" title="根据id更新"></a>根据id更新</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-comment">//根据id更新</span><br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserMapperTest</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testUpdateById</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        user.setId(<span class="hljs-number">6L</span>); <span class="hljs-comment">//主键</span><br>        user.setAge(<span class="hljs-number">21</span>); <span class="hljs-comment">//更新的字段</span><br>        <span class="hljs-comment">//根据id更新，更新不为null的字段</span><br>        <span class="hljs-built_in">this</span>.userMapper.updateById(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="根据条件更新"><a href="#根据条件更新" class="headerlink" title="根据条件更新"></a>根据条件更新</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//根据条件更新</span><br><span class="hljs-comment">//QueryWrapper进行更新 封装成对象 匹配条件进行更新</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testUpdate</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>    user.setAge(<span class="hljs-number">22</span>); <span class="hljs-comment">//更新的字段</span><br>    <span class="hljs-comment">//更新的条件</span><br>    QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>    wrapper.eq(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-number">6</span>);<br>    <span class="hljs-comment">//执行更新操作</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.userMapper.update(user, wrapper);<br>    System.out.println(<span class="hljs-string">&quot;result = &quot;</span> + result);<br>&#125;<br><br><br><span class="hljs-comment">//UpdateWrapper进行更新 可以设置set---更新内容的操作</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testUpdate</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//更新的条件以及字段</span><br>    UpdateWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UpdateWrapper</span>&lt;&gt;();<br>    wrapper.eq(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-number">6</span>).set(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">23</span>);<br>    <span class="hljs-comment">//set的字段是数据库表字段</span><br>    <span class="hljs-comment">//执行更新操作</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.userMapper.update(<span class="hljs-literal">null</span>, wrapper);<br>    System.out.println(<span class="hljs-string">&quot;result = &quot;</span> + result);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><h5 id="根据id删除deleteById"><a href="#根据id删除deleteById" class="headerlink" title="根据id删除deleteById"></a>根据id删除deleteById</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDeleteById</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//执行删除操作</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.userMapper.deleteById(<span class="hljs-number">6L</span>);<br>    System.out.println(<span class="hljs-string">&quot;result = &quot;</span> + result);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="根据条件删除deleteByMap"><a href="#根据条件删除deleteByMap" class="headerlink" title="根据条件删除deleteByMap"></a>根据条件删除deleteByMap</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDeleteByMap</span><span class="hljs-params">()</span> &#123;<br>    Map&lt;String, Object&gt; columnMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    columnMap.put(<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-number">20</span>);<br>    columnMap.put(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;张三&quot;</span>);<br>    <span class="hljs-comment">//将columnMap中的元素设置为删除的条件，多个之间为and关系</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.userMapper.deleteByMap(columnMap);<br>    System.out.println(<span class="hljs-string">&quot;result = &quot;</span> + result);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h5><p>更加情况分为两种不同参数的删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDeleteByMap</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//用法一:</span><br>    QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;User&gt;();<br>    wrapper.eq(<span class="hljs-string">&quot;user_name&quot;</span>,<span class="hljs-string">&quot;caocao&quot;</span>).eq(<span class="hljs-string">&quot;password&quot;</span>,<span class="hljs-string">&quot;123&quot;</span>);<br>    <br>    <span class="hljs-comment">//用法二:</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>    user.setUserName(<span class="hljs-string">&quot;caocao&quot;</span>);<br>    user,setPassword(<span class="hljs-string">&quot;123&quot;</span>);<br>    <br>    <br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.userMapper.delete(wrapper);<br>    System.out.println(<span class="hljs-string">&quot;result = &quot;</span> + result);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="deleyeBetchIds"><a href="#deleyeBetchIds" class="headerlink" title="deleyeBetchIds"></a>deleyeBetchIds</h5><p>批量删除 传入的参数需要是一个数组类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDeleteByMap</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//根据id集合批量删除</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.userMapper.deleteBatchIds(Arrays.asList(<span class="hljs-number">1L</span>,<span class="hljs-number">10L</span>,<span class="hljs-number">20L</span>));<br>    System.out.println(<span class="hljs-string">&quot;result = &quot;</span> + result);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h4><h5 id="根据id查询selectById"><a href="#根据id查询selectById" class="headerlink" title="根据id查询selectById"></a>根据id查询selectById</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelectById</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//根据id查询数据</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.userMapper.selectById(<span class="hljs-number">2L</span>);<br>    System.out.println(<span class="hljs-string">&quot;result = &quot;</span> + user);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="根据数组集合查询数据"><a href="#根据数组集合查询数据" class="headerlink" title="根据数组集合查询数据"></a>根据数组集合查询数据</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelectBatchIds</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//根据id集合批量查询</span><br>    List&lt;User&gt; users = <span class="hljs-built_in">this</span>.userMapper.selectBatchIds(Arrays.asList(<span class="hljs-number">2L</span>, <span class="hljs-number">3L</span>, <span class="hljs-number">10L</span>));<br>    <span class="hljs-keyword">for</span> (User user : users) &#123;<br>        System.out.println(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="根据条件查询一条数据selectOne"><a href="#根据条件查询一条数据selectOne" class="headerlink" title="根据条件查询一条数据selectOne"></a>根据条件查询一条数据selectOne</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelectOne</span><span class="hljs-params">()</span> &#123;<br>    QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;User&gt;();<br>    wrapper.eq(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>);<br>    <span class="hljs-comment">//根据条件查询一条数据，如果结果超过一条会报错</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.userMapper.selectOne(wrapper);<br>    System.out.println(user);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="根据条件查询总记录数"><a href="#根据条件查询总记录数" class="headerlink" title="根据条件查询总记录数"></a>根据条件查询总记录数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelectCount</span><span class="hljs-params">()</span> &#123;<br>    QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;User&gt;();<br>    wrapper.gt(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">23</span>); <span class="hljs-comment">//年龄大于23岁</span><br>    <span class="hljs-comment">//根据条件查询数据条数</span><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.userMapper.selectCount(wrapper);<br>    System.out.println(<span class="hljs-string">&quot;count = &quot;</span> + count);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="分页查询selectPage"><a href="#分页查询selectPage" class="headerlink" title="分页查询selectPage"></a>分页查询selectPage</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据 entity 条件，查询全部记录（并翻页）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> page 分页查询条件（可以为 RowBounds.DEFAULT）</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> queryWrapper 实体对象封装操作类（可以为 null）</span><br><span class="hljs-comment"> */</span><br>IPage&lt;T&gt; <span class="hljs-title function_">selectPage</span><span class="hljs-params">(IPage&lt;T&gt; page, <span class="hljs-meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;<br></code></pre></td></tr></table></figure><p>需要进行分页必须写一个mybatis提供的分页插件</p><p><strong>MybatisPlusInterceptor</strong> MybatisPlus的分页拦截器</p><p>MybatisPlus自带的分页插件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span> <span class="hljs-comment">//标记为配置类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MPConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MybatisPlusInterceptor <span class="hljs-title function_">mybatisPlusInterceptor</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">MybatisPlusInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MybatisPlusInterceptor</span>();<br>        interceptor.addInnerInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PaginationInnerInterceptor</span>());<br>        <span class="hljs-keyword">return</span> interceptor;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-meta">@Test</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelectPage</span><span class="hljs-params">()</span> &#123;<br>      <br>      <span class="hljs-comment">//分页条件</span><br>      QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;User&gt;();<br>      wrapper.gt(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">20</span>); <span class="hljs-comment">//年龄大于20岁</span><br>      <br>      Page&lt;User&gt; page = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<span class="hljs-comment">//参数1:第几页，参数二：每页但是条数据</span><br><span class="hljs-comment">//根据条件查询数据</span><br>      IPage&lt;User&gt; iPage = <span class="hljs-built_in">this</span>.userMapper.selectPage(page, wrapper);<br>      System.out.println(<span class="hljs-string">&quot;数据总条数：&quot;</span> + iPage.getTotal());<br>      System.out.println(<span class="hljs-string">&quot;总页数：&quot;</span> + iPage.getPages());<br>      <br>      List&lt;User&gt; users = iPage.getRecords();<span class="hljs-comment">//获得当前页集合数据</span><br>      <span class="hljs-keyword">for</span> (User user : users) &#123;<br>          System.out.println(<span class="hljs-string">&quot;user = &quot;</span> + user);<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="QueryWrapper各参数"><a href="#QueryWrapper各参数" class="headerlink" title="QueryWrapper各参数"></a>QueryWrapper各参数</h3><p><img src="/2022/07/02/MyBatis-Plus/1.png" alt="参数"></p><h3 id="SQL注入原理"><a href="#SQL注入原理" class="headerlink" title="SQL注入原理"></a>SQL注入原理</h3><p>MP在启动后会将BaseMapper中的一系列的方法注册到meppedStatements中</p><p>在MP中，ISqlInjector负责SQL的注入工作，它是一个接口，AbstractSqlInjector是它的实现类</p><p><img src="/2022/07/02/MyBatis-Plus/2.png" alt="img"></p><p>在AbstractSqlInjector中，主要是由inspectInject()方法进行注入的，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inspectInject</span><span class="hljs-params">(MapperBuilderAssistant builderAssistant, Class&lt;?&gt;</span><br><span class="hljs-params">        mapperClass)</span> &#123;<br>    Class&lt;?&gt; modelClass = extractModelClass(mapperClass);<br>    <span class="hljs-keyword">if</span> (modelClass != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> mapperClass.toString();<br>        Set&lt;String&gt; mapperRegistryCache =<br>                GlobalConfigUtils.getMapperRegistryCache(builderAssistant.getConfiguration());<br>        <span class="hljs-keyword">if</span> (!mapperRegistryCache.contains(className)) &#123;<br>            List&lt;AbstractMethod&gt; methodList = <span class="hljs-built_in">this</span>.getMethodList();<br>            <span class="hljs-keyword">if</span> (CollectionUtils.isNotEmpty(methodList)) &#123;<br>                <span class="hljs-type">TableInfo</span> <span class="hljs-variable">tableInfo</span> <span class="hljs-operator">=</span> TableInfoHelper.initTableInfo(builderAssistant,<br>                        modelClass);<br>                <span class="hljs-comment">// 循环注入自定义方法</span><br>                methodList.forEach(m -&gt; m.inject(builderAssistant, mapperClass,<br>                        modelClass, tableInfo));<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                logger.debug(mapperClass.toString() + <span class="hljs-string">&quot;, No effective injection method</span><br><span class="hljs-string">                        was found.&quot;</span>);<br>            &#125;<br>            mapperRegistryCache.add(className);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在实现方法中， methodList.forEach(m -&gt; m.inject(builderAssistant, mapperClass, modelClass,<br>tableInfo)); 是关键，循环遍历方法，进行注入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 注入自定义 MappedStatement</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> mapperClass mapper 接口</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> modelClass mapper 泛型</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> tableInfo 数据库表反射信息</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> MappedStatement</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> MappedStatement <span class="hljs-title function_">injectMappedStatement</span><span class="hljs-params">(Class&lt;?&gt; mapperClass, Class&lt;?</span><br><span class="hljs-params">        &gt; modelClass, TableInfo tableInfo)</span>;<br></code></pre></td></tr></table></figure><h1 id="后置内容再添加"><a href="#后置内容再添加" class="headerlink" title="后置内容再添加"></a>后置内容再添加</h1>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis-Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>期末复习</title>
    <link href="/2022/06/18/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    <url>/2022/06/18/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="期末考试"><a href="#期末考试" class="headerlink" title="期末考试"></a>期末考试</h1><h3 id="大多以背为主"><a href="#大多以背为主" class="headerlink" title="大多以背为主"></a>大多以背为主</h3><h3 id="分个时间段"><a href="#分个时间段" class="headerlink" title="分个时间段"></a>分个时间段</h3><h4 id="1-18-19号主要是复习毛概-大英-大学生心理健康-抽空看一下-设计模式"><a href="#1-18-19号主要是复习毛概-大英-大学生心理健康-抽空看一下-设计模式" class="headerlink" title="1. 18 19号主要是复习毛概 大英 大学生心理健康 抽空看一下 设计模式"></a>1. 18 19号主要是复习毛概 大英 大学生心理健康 抽空看一下 设计模式</h4><h5 id="毛概"><a href="#毛概" class="headerlink" title="毛概"></a>毛概</h5><p>复习pdf文档 混个眼熟为主</p><h5 id="大学生心理健康"><a href="#大学生心理健康" class="headerlink" title="大学生心理健康"></a>大学生心理健康</h5><p>查看学习通上课程选择题 眼熟为主</p><h5 id="大英"><a href="#大英" class="headerlink" title="大英"></a>大英</h5><p>背诵U1-5的txtA课后习题</p><p>记牢对应单词匹配</p><p>无听了</p><h4 id="2-22号上午复习设计模式-以国王游戏-糖果-解释器模式为主"><a href="#2-22号上午复习设计模式-以国王游戏-糖果-解释器模式为主" class="headerlink" title="2. 22号上午复习设计模式 以国王游戏 糖果  解释器模式为主"></a>2. 22号上午复习设计模式 以国王游戏 糖果  解释器模式为主</h4><p>设计模式复习文档 大概率出原题 </p><h4 id="3-23号复习linux"><a href="#3-23号复习linux" class="headerlink" title="3. 23号复习linux"></a>3. 23号复习linux</h4><p>主要为课堂ppt</p><h4 id="4-25号考计算机组成原理"><a href="#4-25号考计算机组成原理" class="headerlink" title="4. 25号考计算机组成原理"></a>4. 25号考计算机组成原理</h4><p>计组开卷 适当复习即可</p><h4 id="5-26号复习数据库"><a href="#5-26号复习数据库" class="headerlink" title="5. 26号复习数据库"></a>5. 26号复习数据库</h4><p>复习期末大纲 要回看平时作业 数据库范式和er图绘制</p>]]></content>
    
    
    <categories>
      
      <category>状态</category>
      
    </categories>
    
    
    <tags>
      
      <tag>day 3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java命名规范</title>
    <link href="/2022/06/16/Java%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/"/>
    <url>/2022/06/16/Java%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<h1 id="JAVA命名规范"><a href="#JAVA命名规范" class="headerlink" title="JAVA命名规范"></a>JAVA命名规范</h1><p><strong>JAVA编码规范</strong></p><p>1 <strong>目的</strong></p><p>为了保证所每个项目组编写出的程序都符合相同的规范，便于理解和维护，便于检查、减少出错概率，有助于成员间交流，保证一致性、统一性而建立的java程序编码规范。</p><p>2 <strong>范围</strong></p><p>该规范适用于所有基于JAVA开发的项目。</p><p>3 <strong>规范内容</strong></p><p><strong>3.1 命名规范</strong></p><p><strong>包(package)命名</strong></p><ol><li><p>package名字必须由小写字母组成的英文单词或拼音组成</p></li><li><p>英文单词或拼音的含义必须能够大致表示该package的用途</p></li><li><p>多个单词或拼音的构成命名，第一个单词(可缩写)全部小写，第二个单词(可缩写)的首字母必须大写，其余字母小写</p></li><li><p>所有的package都必须使用com.philwong.package1Name的命名结构</p></li></ol><p><strong>类(class)命名</strong></p><ol><li><p>Class命名必须由大写字母开头，后面的字母由小写字母组成的英文单词或拼音组成</p></li><li><p>英文单词或拼音的含义必须能够大致表示该class的用途</p></li><li><p>多个单词或拼音的构成命名，第一个单词或拼音(可缩写)全部小写，第二个单词或拼音(可缩写)的首字母必须大写，其余字母小写</p></li><li><p>servlet 类必须使用类名 + Servlet的结构</p></li><li><p>实体类(entity class)必须使用实体名称的英文单词或拼音命名</p></li><li><p>实体管理类(entity Manager)必须使用实体名称的英文单词或拼音+Manager的结构</p></li><li><p>仅返回结果集的用于数据库查询的servlet使用dso + 英文单词或拼音 + Servlet</p></li><li><p>用于初始化服务器或数据库或者在服务器启动时执行的servlet使用init + 英文单词或拼音 + Servlet</p></li><li><p>返回业务逻辑的servlet使用logic + 英文单词或拼音 + Servlet</p></li></ol><p><strong>类变量和常量的命名</strong></p><ol><li><p>类变量和常量的命名必须使用小写字母构成的英文单词或拼音</p></li><li><p>多个单词或拼音的构成命名，第一个单词(可缩写)全部小写，第二个单词(可缩写)的首字母必须大写，其余字母小写</p></li><li><p>静态变量的命名必须使用static标示</p></li><li><p>必须使用protect、public、private标示类变量和常量；缺省可省略的public标示符也必须注明，不能省略</p></li><li><p>常量命名全部使用大写字母构成的英文单词和拼音</p></li><li><p>同名类变量或常量使用变量名或者常量命的英文单词或拼音+下划线+阿拉伯数字构成用于区分</p></li></ol><p><strong>参数命名</strong></p><ol><li><p>参数的命名必须使用小写字母构成的英文单词或拼音</p></li><li><p>多个单词或拼音的构成命名，第一个单词(可缩写)全部小写，第二个单词(可缩写)的首字母必须大写，其余字母小写</p></li><li><p>同名参数的英文单词或拼音+下划线+阿拉伯数字构成用于区分</p></li><li><p>参数命名必须能够标示其含义</p></li></ol><p><strong>数组命名</strong></p><ol><li><p>数组必须使用小写字母构成的英文单词或拼音+[ ]</p></li><li><p>多个单词或拼音的构成命名，第一个单词(可缩写)全部小写，第二个单词(可缩写)的首字母必须大写，其余字母小写</p></li><li><p>数组总是使用：String arrary[ ] 命名，而不是 String[] array</p></li><li><p>数组命名必须能够标示其含义</p></li></ol><p><strong>方法的命名</strong></p><ol><li><p>方法必须使用小写字母构成的英文单词或拼音</p></li><li><p>多个单词或拼音的构成命名，第一个单词(可缩写)全部小写，第二个单词(可缩写)的首字母必须大写，其余字母小写</p></li><li><p>方法的命名必须能够标示其含义</p></li><li><p>静态方法必须使用static标示</p></li><li><p>必须使用protect、public、private标示方法；缺省可省略的public标示符也必须注明，不能省略</p></li></ol><p><strong>其它相关文件的命名</strong></p><p>(jsp文件、javaScript文件、图片文件、css文件、xml文件、DTD文件、xsl文件、属性配置文件、HTML文件)</p><ol><li><p>文件的命名必须使用小写字母构成的英文单词或拼音</p></li><li><p>多个单词或拼音的构成命名，第一个单词(可缩写)全部小写，第二个单词(可缩写)的首字母必须大写，其余字母小写</p></li><li><p>文件的命名必须能够标示其含义</p></li><li><p>属性配置文件名后缀使用 *.property</p></li><li><p>jsp文件的</p></li></ol><p><strong>HTML相关对象的命名</strong></p><ol><li><p>命名必须使用小写字母构成的英文单词或拼音</p></li><li><p>多个单词或拼音的构成命名，第一个单词(可缩写)全部小写，第二个单词(可缩写)的首字母必须大写，其余字母小写</p></li><li><p>命名必须能够标示其含义</p></li><li><p>field： fld + 单词或拼音</p></li><li><p>textArea：ta + 单词或拼音</p></li><li><p>checkbox: cb + 单词或拼音</p></li><li><p>radioBox: rb + + 单词或拼音</p></li><li><p>image : img + 单词或拼音</p></li><li><p>link : lk + 单词或拼音</p></li><li><p>hiddenFileld : hiddenFld + 单词或拼音</p></li><li><p>pullDownSelection: ps + 单词或拼音</p></li><li><p>horizonLine: hl + 单词或拼音</p></li><li><p>button : btn + 单词或拼音</p></li><li><p>imageButton : imgBtn + 单词或拼音</p></li><li><p>banner : ban + 单词或拼音</p></li></ol><p><strong>3.2 文件样式规范</strong></p><p><strong>版权信息</strong></p><p>/**</p><p>*Copyright 2003 电子计算技术研究所</p><p>*All Right Reserved</p><p>*Author ：作者姓名</p><p>*编码日期格式：YYYY-MM-DD</p><p>*/</p><p><strong>package/import</strong></p><p>package行要在import之前，import中标准的包名要在本地的包名之前，而且字母顺序排列；如果import行中包括同一包中的不同子目录，则应该使用*来处理;二者之间应该空一行</p><p>package com.philwong.system.configManager;</p><p>import com.philwong.philwongException.*;</p><p>import java.io.*;</p><p>import java.util.Observable;</p><p><strong>类注释和类定义</strong></p><p>类注释用于解释类的结构和主要功能</p><p>/**</p><p>*编码实现的功能简要描述以及注意事项</p><p>*</p><p>*/</p><p>类定义：</p><p>public configManager</p><p>extend Property</p><p>implements Cloneable {</p><p>}</p><p><strong>成员变量</strong></p><p>public 类型的成员变量必须做出注释说明;同一变量类型定义在一起；不同类型变量之间空一行</p><p>/**</p><p>*配置文件的文件名和路径</p><p>*/</p><p>public String fileName = “”;</p><p>public String filePath = “”;</p><p>protected java.sql.Date createdDate = null;</p><p>…</p><p><strong>成员变量存取方法(不是必需的)</strong></p><p>/**</p><p>*成员变量存取方法注释说明</p><p>*/</p><p>public String getFileName(){ return filename };</p><p>…</p><p><strong>构造函数</strong></p><p>构造函数采取递增的方式，参数多的放在后面</p><p>public configManager() {</p><p>..</p><p>}</p><p>public configManager(String fileName) {</p><p>..</p><p>}</p><p>public configManager(String filename,String filePath) {</p><p>..</p><p>}</p><p><strong>成员方法</strong></p><ol><li><p>每一个类尽可能都定义一个toString()方法</p></li><li><p>如果有main()方法，那么应该放在类的底部</p></li><li><p>每个方法之间空一行</p></li></ol><p><strong>修改注释说明</strong></p><p><strong>/*</strong>*</p><p>*****修改说明：</p><p>*****修改人： 修改日期：</p><p>*****修改原因：</p><p>***/**</p><p>public setFilePath(String filePath) {</p><p>//old code remark line 124</p><p>//this.filePath = filePath;</p><p>//new code 126 –130</p><p>if (filePath = = null) {</p><p>this.filePath = “”;</p><p>} else {</p><p>this.filePath = filePath;</p><p>}</p><p>}</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Day 2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BS CS架构了解</title>
    <link href="/2022/06/16/BS-CS%E6%9E%B6%E6%9E%84%E4%BA%86%E8%A7%A3/"/>
    <url>/2022/06/16/BS-CS%E6%9E%B6%E6%9E%84%E4%BA%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="B-S-C-S架构了解"><a href="#B-S-C-S架构了解" class="headerlink" title="B/S C/S架构了解"></a>B/S C/S架构了解</h1><p><a href="https://blog.csdn.net/sea_snow/article/details/81187804"> 深入理解B/S与C/S架构_雪飞_海的博客-CSDN博客_b/s架构</a></p><p>一、什么是C/S架构<br>C/S架构是第一种比较早的软件架构，主要用于局域网内。也叫 客户机/服务器模式。</p><p>它可以分为客户机和服务器两层：</p><p>第一层:  在客户机系统上结合了界面显示与业务逻辑；</p><p>第二层:  通过网络结合了数据库服务器。</p><p>简单的说就是第一层是用户表示层，第二层是数据库层。</p><p>　 这里需要补充的是，客户端不仅仅是一些简单的操作，它也是会处理一些运算，业务逻辑的处理等。也就是说，客户端也做着一些本该由服务器来做的一些事情，如图所示：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvMTA0NjA3NS8yMDE3MTEvMTA0NjA3NS0yMDE3MTEwMzEzMjExOTE4NS0yMDk2MzA0NDY4LnBuZw?x-oss-process=image/format,png" alt="img"></p><p>C/S架构软件有一个特点，就是如果用户要使用的话，需要下载一个客户端，安装后就可以使用。比如QQ,OFFICE软件等。</p><p>1、C/S架构的优点：</p><p>1 C/S架构的界面和操作可以很丰富。（客户端操作界面可以随意排列，满足客户的需要）</p><p>2 安全性能可以很容易保证。（因为只有两层的传输，而不是中间有很多层。</p><p>3 由于只有一层交互，因此响应速度较快。（直接相连，中间没有什么阻隔或岔路，比如QQ，每天那么多人在线，也不觉得慢）</p><p>2、C/S架构的缺点：</p><p>可以将QQ作为类比：</p><p>1 适用面窄，通常用于局域网中。</p><p>2 用户群固定。由于程序需要安装才可使用，因此不适合面向一些不可知的用户。</p><p>3 维护成本高，发生一次升级，则所有客户端的程序都需要改变。</p><p>二、什么是B/S架构<br>B/S架构的全称为Browser/Server，即浏览器/服务器结构。</p><p>Browser指的是Web浏览器，极少数事务逻辑在前端实现，但主要事务逻辑在服务器端实现。</p><p>B/S架构的系统无须特别安装，只有Web浏览器即可。</p><p>其实就是我们前端现在做的一些事情，大部分的逻辑交给后台来实现，我们前端大部分是做一些数据渲染，请求等比较少的逻辑。</p><p>B/S架构的分层：</p><p>与C/S架构只有两层不同的是，B/S架构有三层，分别为：</p><p>第一层表现层：主要完成用户和后台的交互及最终查询结果的输出功能。</p><p>第二层逻辑层：主要是利用服务器完成客户端的应用逻辑功能。</p><p>第三层数据层：主要是接受客户端请求后独立进行各种运算。</p><p>如图所示：</p><p><img src="https://img-blog.csdnimg.cn/20200118143816483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NlYV9zbm93,size_16,color_FFFFFF,t_70" alt="img"></p><p>B/S架构的优点：</p><p>1、客户端无需安装，有Web浏览器即可。<br>2、BS架构可以直接放在广域网上，通过一定的权限控制实现多客户访问的目的，交互性较强。<br>3、BS架构无需升级多个客户端，升级服务器即可。可以随时更新版本，而无需用户重新下载啊什么的。</p><p>B/S架构的缺点：</p><p>1、在跨浏览器上，BS架构不尽如人意。<br>2、表现要达到CS程序的程度需要花费不少精力。<br>3、在速度和安全性上需要花费巨大的设计成本，这是BS架构的最大问题。<br>4、客户端服务器端的交互是请求-响应模式，通常需要刷新页面，这并不是客户乐意看到的。（在Ajax风行后此问题得到了一定程度的缓解）</p><p>三、B/S架构的几种形式<br>第一种：客户端-服务器-数据库</p><p><img src="https://img-blog.csdnimg.cn/20200118152126513.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NlYV9zbm93,size_16,color_FFFFFF,t_70" alt="img"></p><p>这个应该是我们平时比较常用的一种模式：</p><p>1、客户端向服务器发起Http请求</p><p>2、服务器中的web服务层能够处理Http请求</p><p>3、服务器中的应用层部分调用业务逻辑，调用业务逻辑上的方法</p><p>4、如果有必要，服务器会和数据库进行数据交换. 然后将模版＋数据渲染成最终的Html, 返送给客户端</p><p>第二种：客户端－web服务器－应用服务器－数据库</p><p><img src="https://img-blog.csdnimg.cn/20200118151926798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NlYV9zbm93,size_16,color_FFFFFF,t_70" alt="img"></p><p> 类似于第一种方法，只是将web服务和应用服务解耦</p><p>1 客户端向web服务器发起Http请求</p><p>2 web服务能够处理Http请求，并且调用应用服务器暴露在外的RESTFUL接口</p><p>3 应用服务器的RESTFUL接口被调用，会执行对应的暴露方法.如果有必要和数据库进行数据交互，应用服务器会和数据库进行交互后，将json数据返回给web服务器</p><p>4 web服务器将模版＋数据组合渲染成html返回给客户端</p><p>第三种方法：客户端－负载均衡器(Nginx)－中间服务器(Node)－应用服务器－数据库</p><p>这种模式一般用在有大量的用户，高并发的应用中。<img src="https://img-blog.csdnimg.cn/20200118152234550.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NlYV9zbm93,size_16,color_FFFFFF,t_70" alt="img"></p><p>1、整正暴露在外的不是真正web服务器的地址，而是负载均衡器器的地址</p><p>2、客户向负载均衡器发起Http请求</p><p>3、负载均衡器能够将客户端的Http请求均匀的转发给Node服务器集群</p><p>4、Node服务器接收到Http请求之后，能够对其进行解析，并且能够调用应用服务器暴露在外的RESTFUL接口</p><p>5、应用服务器的RESTFUL接口被调用，会执行对应的暴露方法.如果有必要和数据库进行数据交互，应用服务器会和数据库进行交互后，将json数据返回给Node</p><p>6、Node层将模版＋数据组合渲染成html返回反向代理服务器</p><p>7、反向代理服务器将对应html返回给客户端</p><p>Nginx的优点有:</p><p>1、它能够承受、高并发的大量的请求，然后将这些请求均匀的转发给内部的服务器，分摊压力.</p><p>2、反向代理能够解决跨域引起的问题，因为Nginx，Node,应用服务器，数据库都处于内网段中。</p><p>3、Nginx非常擅长处理静态资源(img,css,js,video)，所以也经常作为静态资源服务器，也就是我们平时所说的CDN</p><p>　　比如：前一个用户访问index.html, 经过Nginx－Node－应用服务器－数据库链路之后，Nginx会把index.html返回给用户，并且会把index.html缓存在Nginx上，</p><p>　　下一个用户再想请求index.html的时候，请求Nginx服务器，Nginx发现有index.html的缓存，于是就不用去请求Node层了，会直接将缓存的页面(如果没过期的话)返回给用户。</p><p>四、发展前景</p><p>1、 C/S和B/S各有优势，C/S在图形的表现能力上以及运行的速度上肯定是强于B/S模式的，不过缺点就是他需要运行专门的客户端，而且更重要的是它不能跨平台，用c++在windows下写的程序肯定是不能在linux下跑的。</p><p>2、B/S模式就，它不需要专门的客户端，只要浏览器，而浏览器是随操作系统就有的，方便就是他的优势了。<br>而且，B/S是基于网页语言的、与操作系统无关，所以跨平台也是它的优势，而且以后随着网页语言以及浏览器的进步，<br>B/S在表现能力上的处理以及运行的速度上会越来越快，它的缺点将会越来越少。尤其是HTML5的普及，在图形的渲染方面以及音频、文件的处理上已经非常强大了。 </p>]]></content>
    
    
    <categories>
      
      <category>交流架构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Day 2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>响应状态码</title>
    <link href="/2022/06/16/%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    <url>/2022/06/16/%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h2 id="一、状态码大类"><a href="#一、状态码大类" class="headerlink" title="一、状态码大类"></a>一、状态码大类</h2><table><thead><tr><th>状态码分类</th><th>说明</th></tr></thead><tbody><tr><td>1xx</td><td><strong>响应中</strong>——临时状态码，表示请求已经接受，告诉客户端应该继续请求或者如果它已经完成则忽略它</td></tr><tr><td>2xx</td><td><strong>成功</strong>——表示请求已经被成功接收，处理已完成</td></tr><tr><td>3xx</td><td><strong>重定向</strong>——重定向到其它地方：它让客户端再发起一个请求以完成整个处理。</td></tr><tr><td>4xx</td><td><strong>客户端错误</strong>——处理发生错误，责任在客户端，如：客户端的请求一个不存在的资源，客户端未被授权，禁止访问等</td></tr><tr><td>5xx</td><td><strong>服务器端错误</strong>——处理发生错误，责任在服务端，如：服务端抛出异常，路由出错，HTTP版本不支持等</td></tr></tbody></table><p>状态码大全：<a href="https://cloud.tencent.com/developer/chapter/13553">https://cloud.tencent.com/developer/chapter/13553</a> </p><h2 id="二、常见的响应状态码"><a href="#二、常见的响应状态码" class="headerlink" title="二、常见的响应状态码"></a>二、常见的响应状态码</h2><table><thead><tr><th>状态码</th><th>英文描述</th><th>解释</th></tr></thead><tbody><tr><td>200</td><td><strong><code>OK</code></strong></td><td>客户端请求成功，即<strong>处理成功</strong>，这是我们最想看到的状态码</td></tr><tr><td>302</td><td><strong><code>Found</code></strong></td><td>指示所请求的资源已移动到由<code>Location</code>响应头给定的 URL，浏览器会自动重新访问到这个页面</td></tr><tr><td>304</td><td><strong><code>Not Modified</code></strong></td><td>告诉客户端，你请求的资源至上次取得后，服务端并未更改，你直接用你本地缓存吧。隐式重定向</td></tr><tr><td>400</td><td><strong><code>Bad Request</code></strong></td><td>客户端请求有<strong>语法错误</strong>，不能被服务器所理解</td></tr><tr><td>403</td><td><strong><code>Forbidden</code></strong></td><td>服务器收到请求，但是<strong>拒绝提供服务</strong>，比如：没有权限访问相关资源</td></tr><tr><td>404</td><td><strong><code>Not Found</code></strong></td><td><strong>请求资源不存在</strong>，一般是URL输入有误，或者网站资源被删除了</td></tr><tr><td>428</td><td><strong><code>Precondition Required</code></strong></td><td><strong>服务器要求有条件的请求</strong>，告诉客户端要想访问该资源，必须携带特定的请求头</td></tr><tr><td>429</td><td><strong><code>Too Many Requests</code></strong></td><td><strong>太多请求</strong>，可以限制客户端请求某个资源的数量，配合 Retry-After(多长时间后可以请求)响应头一起使用</td></tr><tr><td>431</td><td><strong><code> Request Header Fields Too Large</code></strong></td><td><strong>请求头太大</strong>，服务器不愿意处理请求，因为它的头部字段太大。请求可以在减少请求头域的大小后重新提交。</td></tr><tr><td>405</td><td><strong><code>Method Not Allowed</code></strong></td><td>请求方式有误，比如应该用GET请求方式的资源，用了POST</td></tr><tr><td>500</td><td><strong><code>Internal Server Error</code></strong></td><td><strong>服务器发生不可预期的错误</strong>。服务器出异常了，赶紧看日志去吧</td></tr><tr><td>503</td><td><strong><code>Service Unavailable</code></strong></td><td><strong>服务器尚未准备好处理请求</strong>，服务器刚刚启动，还未初始化好</td></tr><tr><td>511</td><td><strong><code>Network Authentication Required</code></strong></td><td><strong>客户端需要进行身份验证才能获得网络访问权限</strong></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>web页面响应</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Day 2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的第一篇博客</title>
    <link href="/2022/06/15/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <url>/2022/06/15/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="标语"><a href="#标语" class="headerlink" title="标语"></a>标语</h1><h2 id="记录我的第一篇博客-开设编写对fluid主题的配置进行完善"><a href="#记录我的第一篇博客-开设编写对fluid主题的配置进行完善" class="headerlink" title="记录我的第一篇博客 开设编写对fluid主题的配置进行完善"></a>记录我的第一篇博客 开设编写对fluid主题的配置进行完善</h2><p>我的第一篇博客</p><ul><li>学习fluid主题配置的更新</li><li>完善对对应图片更换</li><li>学习博客的使用</li></ul>]]></content>
    
    
    <categories>
      
      <category>first blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Day 1</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/06/07/hello-world/"/>
    <url>/2022/06/07/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
